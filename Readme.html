<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>diskbench</title><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id366079"></a><span class="package">diskbench</span></h2></div><div><h3 class="subtitle"><i>A collection of simple low-level command-line disk benchmark utilities.</i></h3></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id366943">Introduction</a></span></dt><dt><span class="sect1"><a href="#id416300">The Utilities</a></span></dt><dt><span class="sect1"><a href="#id416818">Interpreting the Results</a></span></dt><dt><span class="sect1"><a href="#id416835">Compatibility</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id366943"></a>Introduction</h2></div></div></div><p>This document describes <span class="package">diskbench</span>, a collection of simple low-level disk benchmarks implemented as command-line C programs.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>This is currently a work-in-progress and should be considered alpha-quality.  Don&#8217;t expect it to work, and use at your own risk!</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id416300"></a>The Utilities</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You will probably have to run these commands as root in order to access the raw disk devices.</p></div><p>The output of these commands is tab-separated text, and should be easy to use in producing graphs (recommended!).</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>seqread</strong></span></span></dt><dd><p>Performs a series of large sequential read operations across the device, reporting the transfer rate for each.  This will give an indication of the sustained bandwidth of the disk.</p><p>This benchmark may be more relevant for applications dealing with individual large files, such as audio/video and image manipulation.</p></dd><dt><span class="term"><span class="command"><strong>randread</strong></span></span></dt><dd><p>Performs a series of random reads of one block in size, reporting the time per operation in milliseconds, and the transfer rate.</p><p>Random I/O operations occur more frequently in typical database applications, typical defragmentation routines, and applications involving large numbers of small files, especially under heavy concurrency.</p><p>Because the operation includes the retrieval of the block, the time reported will be slightly higher than the actual access time (but generally not by very much).</p></dd><dt><span class="term"><span class="command"><strong>burstread</strong></span></span></dt><dd><p>Repeatedly re-reads the same chunk of data from the device, so that it will be retrieved from the disk drive cache rather than from the physical medium.</p><p>Burst (cache) reads occur when the same data are retrieved repeatedly by the system, especially when subsequent reads happen soon after the initial read.</p></dd></dl></div><p>The commands are intended to operate on entire disk drive, so the argument will usually be the special device file for the raw, whole disk you wish to test (e.g. <code class="filename">/dev/sda</code>).  However, you can also test individual partitions (e.g. <code class="filename">/dev/sda1</code>) or individual files (<code class="filename">~/Video/Wedding.avi</code>), in which case the apparent performance will probably be much greater
			<sup>[<a name="id416747" href="#ftn.id416747" class="footnote">1</a>]</sup>
		, and not comparable with other systems.</p><p>On NetBSD, you must use the raw disk device special file, e.g. <code class="filename">/dev/rwd0d</code> rather than <code class="filename">/dev/wd0d</code>, otherwise the results will be quite wrong.</p><p>If you have no idea what device filename to use, try one of these:</p><div class="itemizedlist"><ul type="disc"><li>Linux:	<code class="filename">/dev/sda</code> or <code class="filename">/dev/hda</code></li><li>NetBSD:	<code class="filename">/dev/rwd0d</code> or <code class="filename">/dev/rsd0d</code></li></ul></div><p>Also included is a simple program <span class="command"><strong>rewrite</strong></span>, which will read and write a disk/partition/file, leaving the data unchanged, but potentially causing the drive to detect and re-map any sectors that may be in the process of going bad.  This is no substitute for a backup, of course, but may be useful anyway.  Because it does one sector at a time, expect it to be extremely slow.  For cases in which sectors have already become unreadable, try <span class="command"><strong>ddrescue</strong></span> (another fine GNU utility from the Free Software Foundation).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id416818"></a>Interpreting the Results</h2></div></div></div><p>There are lies, damned lies, and statistics, so the saying goes.  It is virtually impossible to test the performance of one component of a computer system without being affected by other components.  Disk benchmarks will be affected by the interface: for example, the bandwidth bottleneck for USB-connected drives is probably the interface, not the drive.  On some systems, it may be impossible to avoid the effects of data caches and buffers, in particular those provided by the operating system, host adapter (if present), and the disk drive itself.  Bridges in external drive enclosures may affect latency and bandwidth.  However, under ideal conditions and if you keep your skeptical hat on, you should be able to get results that are fairly close to the mark and reproducible.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id416835"></a>Compatibility</h2></div></div></div><p>My intention is to have the diskbench programs compile and run on NetBSD, Linux, Cygwin/Windows, Mac OS X, and MINIX 3.  Other POSIX compliant systems should be easy to support (they may even just work).</p><p>Linux kernel version 2.6.10 or later are necessary for <code class="code">O_DIRECT</code> support.</p><p>Currently diskbench should (be able to be made to) work on NetBSD, Linux and Cygwin systems, since I have ready access to these and can test them.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id416747" href="#id416747" class="para">1</a>] </sup>You can sacrifice capacity for performance when partitioning a drive.  The data at the outside edge of a disk will generally experience faster sequential data rates (perhaps 2x the speed of the inside edge), so using a small slice of the disk will effectively give a small, fast disk.  This will also benefit access times and random I/O performance, since the read/write head need only move within a much smaller region of the disk.</p></div></div></div></body></html>
