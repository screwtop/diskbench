<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>diskbench</title><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id460668"></a><span class="package">diskbench</span></h2></div><div><h3 class="subtitle"><i>A collection of simple low-level command-line disk benchmark utilities.</i></h3></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id424197">Introduction</a></span></dt><dt><span class="sect1"><a href="#id460722">Design Objectives</a></span></dt><dt><span class="sect1"><a href="#id425036">The Utilities</a></span></dt><dt><span class="sect1"><a href="#id453634">Compatibility</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id424197"></a>Introduction</h2></div></div></div><p>This document describes <span class="package">diskbench</span>, a collection of simple low-level disk benchmarks implemented as command-line C programs.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>This is currently a work-in-progress and should be considered alpha-quality.  Don&#8217;t expect it to work, and use at your own risk!</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id460722"></a>Design Objectives</h2></div></div></div><p>The design objectives for diskbench have always been very modest.  I don't consider myself a C programmer, but it was clearly a good language for the job.</p><div class="variablelist"><p class="title"><b>The main design objectives:</b></p><dl><dt><span class="term">Cover the basics.</span></dt><dd><p>The tests should cover the three basic low-level metrics for mechanical hard disk drive performance: access times, sequential transfer rate, and interface speed.  These metrics allow different drives to be compared quickly and easily, but has the drawback of not taking into account the caching algorithms used by the drive (sometimes referred to as the drive firmware).  For real-world application workloads, especially in desktop environments where disk activity is triggered by a single user and tends to feature highly localised patterns of access, the cacheing behaviour of the drive can have a major effect on the overall speed (IOPS: input/output operations per second).</p></dd><dt><span class="term">Be non-destructive.</span></dt><dd><p>The files being tested are opened in read-only mode, so it should be impossible to damage or erase any data using these tools.  You can therefore happily use these benchmarks on partitioned disks with data on them (although if other system processes are using the disk, the results will not be pure).  This has the drawback that you cannot test the performance of write operations, which are extremely important in many applications.   The type of drive, interface, or configuration (e.g. RAID) can have a significant effect on the relative write-vs.-read performance, which diskbench will not help you identify.</p></dd><dt><span class="term">Be simple.</span></dt><dd><p>The measurements are conceptually simple; the programs should be simple as well.  Complexity leads to overhead and fuzzier benchmark results.</p></dd><dt><span class="term">Be portable.</span></dt><dd><p>I wanted to be able to run these benchmarks on a variety of different systems that I use frequently.  The programs should be quite portable due to their simplicity, the use of C as an implementation language, and the use of standard library calls.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id425036"></a>The Utilities</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You will probably have to run these commands as root in order to access the raw disk devices.  The three main benchmarking programs perform non-destructive, read-only testing.</p></div><p>The output of these commands is tab-separated text, and should be easy to use in producing graphs (recommended!).</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>seqread</strong></span></span></dt><dd><p>Performs a series of large sequential read operations across the device, reporting the transfer rate for each.  This will give an indication of the sustained bandwidth of the disk.</p><p>This benchmark may be more relevant for applications dealing with individual large files, such as audio/video and image manipulation.</p></dd><dt><span class="term"><span class="command"><strong>randread</strong></span></span></dt><dd><p>Performs a series of random reads of one block in size, reporting the time per operation in milliseconds, and the transfer rate.</p><p>Random I/O operations occur more frequently in typical database applications, typical defragmentation routines, and applications involving large numbers of small files, especially under heavy concurrency.</p><p>Because the operation includes the retrieval of the block, the time reported will be slightly higher than the actual access time (but generally not by very much).</p></dd><dt><span class="term"><span class="command"><strong>burstread</strong></span></span></dt><dd><p>Repeatedly re-reads the same chunk of data from the device, so that it will be retrieved from the disk drive cache rather than from the physical medium.</p><p>Burst (cache) reads occur when the same data are retrieved repeatedly by the system, especially when subsequent reads happen soon after the initial read.</p></dd></dl></div><p>The commands are intended to operate on an entire disk drive, so the argument will usually be the special device file for the raw, whole disk you wish to test (e.g. <code class="filename">/dev/sda</code>).  However, you can also test individual partitions (e.g. <code class="filename">/dev/sda1</code>) or individual files (<code class="filename">~/Video/Wedding.avi</code>), in which case the apparent performance will probably be much greater
			<sup>[<a name="id431608" href="#ftn.id431608" class="footnote">1</a>]</sup>
		, and not comparable with other systems.</p><p>On NetBSD, you must use the raw disk device special file, e.g. <code class="filename">/dev/rwd0d</code> rather than <code class="filename">/dev/wd0d</code>, otherwise the results will be quite wrong.</p><p>If you have no idea what device filename to use, try one of these:</p><div class="itemizedlist"><ul type="disc"><li>Linux:	<code class="filename">/dev/sda</code> or <code class="filename">/dev/hda</code></li><li>NetBSD:	<code class="filename">/dev/rwd0d</code> or <code class="filename">/dev/rsd0d</code></li></ul></div><p>Also included is a simple program <span class="command"><strong>rewrite</strong></span>, which will read and write a disk/partition/file, leaving the data unchanged, but potentially causing the drive to detect and re-map any sectors that may be in the process of going bad.  This is no substitute for a backup, of course, but may be useful anyway.  Because it does one sector at a time, expect it to be extremely slow.  For cases in which sectors have already become unreadable, try <span class="command"><strong>ddrescue</strong></span> (another fine GNU utility from the Free Software Foundation).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id453634"></a>Compatibility</h2></div></div></div><p>My intention is to have the diskbench programs compile and run on NetBSD, Linux, Cygwin/Windows, Mac OS X, and MINIX 3.  Other POSIX compliant systems should be easy to support (they may even just work).</p><p>Linux kernel version 2.6.10 or later are necessary for <code class="code">O_DIRECT</code> support.</p><p>Currently diskbench should (be able to be made to) work on NetBSD, Linux and Cygwin systems, since I have ready access to these and can test them.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id431608" href="#id431608" class="para">1</a>] </sup>You can sacrifice capacity for performance when partitioning a drive.  The data at the outside edge of a disk will generally experience faster sequential data rates (perhaps 2x the speed of the inside edge), so using a small slice of the disk will effectively give a small, fast disk.  This will also benefit access times and random I/O performance, since the read/write head need only move within a much smaller region of the disk.</p></div></div></div></body></html>
